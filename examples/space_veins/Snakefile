# SPDX-FileCopyrightText: 2023 Mario Franke <research@m-franke.net>
#
# SPDX-License-Identifier: GPL-2.0-or-later

configfile: "smk.config.yaml"

rule buildContainer:
    input:
        "../../singularity/singularity-space_veins.def"
    output:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        singularity build --fakeroot {output} {input}
        """

rule shell:
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        bash
        """

rule buildSpaceVeins:
    input:
        "../../Makefile"
    output:
        "../../bin/space_veins_run"
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        make makefiles
        ucc make -j{threads} all
        make bin/space_veins_run
        """

rule cleanSpaceVeins:
    input:
        "../../Makefile"
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        1
    shell:
        """
        make cleanall
        """

rule createRunmakerFiles:
    input:
        expand("{oppConfig}_runs.log", oppConfig=config["oppConfig"]),
        expand("{oppConfig}_runs.txt", oppConfig=config["oppConfig"]),

rule createRunmakerLogFile:
    output:
        "{oppConfig}_runs.log"
    shell:
        "touch {output}"

rule createRunFile:
    input:
        "omnetpp.ini"
    output:
        "{oppConfig}_runs.txt"
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        cd examples/space_veins && perl ../../lib/veins_scripts/running/generateRunsFile.pl {wildcards.oppConfig} > {output}
        """

rule runAll:
    input:
        expand("{oppConfig}_done.txt", oppConfig=config["oppConfig"])
    # resources:
    #     tasks=len(input.runs),

# create a dummy output file such that snakemake's dependency management works
rule run:
    input:
        logFile="{oppConfig}_runs.log",
        runFile="{oppConfig}_runs.txt"
    output:
        "{oppConfig}_done.txt"
    threads:
        config["numJobsPerConfig"]
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        cd examples/space_veins/ && python3 ../../lib/runmaker/runmaker4.py --jobs={threads} -l {input.logFile} --loglines=200 {input.runFile} && touch {output}
        """

rule debugRun:
    threads:
        1
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        cd examples/space_veins/ && ./run --debug --tool {config[tool]} -- -u {config[env]} -c {config[oppDebugConfig]} -r {config[debugRunNumber]}
        """

def formatScaCsvFileNames():
    files = list()
    f = ""
    for c in config["oppConfig"]:
        for s in config["scalars"]:
            f = "csv/scalars/" + c + "-"
            oppModule = ".".join(s.split(".")[:-1])
            f += oppModule + "-"
            scalar = s.split(".")[-1]
            f += scalar + ".csv"
            files.append(f)
    return files

rule sca2csvAll:
    input:
        formatScaCsvFileNames()
    threads:
        workflow.cores

def formatItervars(wildcards):
    i = ""
    for s in config["itervars"]:
        i += "-I " + s + " "
    return i

def formatScalar(wildcards):
    s = wildcards.scalar.split(".")[-1]
    flags = "-F " + s + "=" + s.replace(":", "_")
    return flags

def formatModuleRegex(wildcards):
    regex = ".".join(wildcards.module.split(".")[:-1])
    regex = regex.replace(".", "\.")
    regex = regex.replace("[", "\[")
    regex = regex.replace("]", "\]")
    regex = regex.replace("*", "(?<module>[0-9]+)")
    regex = "\'^" + regex + "\'"
    return regex

rule sca2csv:
    output:
        "csv/scalars/{oppConfig}-{module}-{scalar}.csv"
    params:
        itervars=formatItervars,
        scalar=formatScalar,
        moduleRegex=formatModuleRegex
    threads:
        1
    shell:
        """
        perl ../../lib/veins_scripts/eval/opp_sca2csv.pl -v -M {params.moduleRegex} {params.scalar} -A repetition {params.itervars} results/{wildcards.oppConfig}*.sca > {output}
        """

def formatVecCsvFileNames():
    files = list()
    f = ""
    for c in config["oppConfig"]:
        for v in config["vectors"]:
            oppModule = ".".join(v.split(".")[:-1])
            vec = v.split(".")[-1]
            f = "csv/vectors/" + c + "-" + oppModule + "-" + vec + ".csv"
            files.append(f)
    return files

rule vec2csvAll:
    input:
        formatVecCsvFileNames()
    output:
        "vec2csvAll_done.txt"
    threads:
        workflow.cores
    shell:
        """
        touch {output}
        """

def get_csvs_to_compose(wildcards):
    constellation = wildcards.composed_constellation
    const_components = config["constellation_compositions"][constellation]
    print(const_components)
    in_csvs = []
    for const_comp in const_components:
        in_csvs.append(f"csv/vector_components/{wildcards.location}_{const_comp}-{wildcards.mobility}_{wildcards.coordframe}_sorted.csv")
    print(in_csvs)
    return in_csvs

rule compose_pos_csvs:
    input:
        script="../../scripts/utility/compose_pos_csvs.py",
        in_csvs=get_csvs_to_compose
    output:
        "csv/vectors/{location}_{composed_constellation}-{mobility}_{coordframe}_sorted.csv"
    shell:
        "python3 {input.script} {output} {input.in_csvs}"


"""
RULES FOR PLOTTING SATELLITE ORBITS
"""

rule satmod_csv:
    """
    Writes 3D coordinates in the specified coordinate frame for the specified satellite module of the specified OMNeT configuration
    to an individual CSV file.
    """
    input:
        script="../../scripts/utility/to_sat_csv.py",
        in_csv="csv/vectors/{location}_{opp_config}_{coord_frame}_sorted.csv"
    output:
        "csv/vectors/satmod/{location}/{opp_config}_{coord_frame}_{leo_modname}.csv"
    shell:
        "python3 {input.script} {input.in_csv} '{wildcards.leo_modname}' > '{output}'"

def get_satmod_csv_paths(wildcards, same_config=True):
    """
    Returns the paths of the CSVs of individual 3D coordinate for the satellite modules of the wildcards list "leo_modnames" of the specified constellation,
    for the specified coordinate frame and either one or two OMNeT configurations, for (1) plotting orbits of one mobility and (2) comparative plot of the 
    orbits of two mobilities.
    """    
    leo_modnames = wildcards.leo_modnames.split("+")

    # one config (= one mobility) -> one csv per satmod 
    if same_config:
        base_path = "csv/vectors/satmod/" + wildcards.location + "/" + wildcards.opp_config + "_" + wildcards.coord_frame + "_"
        return [(base_path + modname + ".csv") for modname in leo_modnames]

    # tw0 configs (= two mobilities) -> two csvs per satmod 
    else:
        mob1_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility1
        mob2_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility2
        mob1_base_path = "csv/vectors/satmod/" + wildcards.location + "/" + mob1_config_str + "_" + wildcards.coord_frame + "_"
        mob2_base_path = "csv/vectors/satmod/" + wildcards.location + "/" + mob2_config_str + "_" + wildcards.coord_frame + "_"
        return [(mob1_base_path + modname + ".csv") for modname in leo_modnames] + [(mob2_base_path + modname + ".csv") for modname in leo_modnames]
    
rule plot_orbs_of_mobility:
    """
    Creates interactive plot of the orbits of the specified "leo_modnames" for the given coordinate frame and OMNeT configuration.
    """
    input:
        "{oppConfig}_done.txt"
    output:
        "csv/vectors/{oppConfig}-{module}-{vector}.csv"
    params:
        itervars=formatItervars,
        vector=formatVector,
        moduleRegex=formatModuleRegex
    threads:
        1
    shell:
        """
        perl ../../lib/veins_scripts/eval/opp_vec2csv.pl -v -M {params.moduleRegex} {params.vector} -A repetition {params.itervars} results/{wildcards.oppConfig}*.vec > {output}
        """