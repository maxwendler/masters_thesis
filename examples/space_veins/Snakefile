import os
import glob
import sys
sys.path.append("/workspaces/ma-max-wendler/scripts/plots")
import json

configfile: "smk.config.yaml"

def get_tles_paths():
    tles_fname_prefixes = config["tles_prefixes"]
    tles_fpaths = [] 
    
    for fname in os.listdir("./tles/"):
        if fname.split("_")[0] in tles_fname_prefixes:
            tles_fpaths.append(f'{"tles/" + fname}')
    
    return tles_fpaths

def quote_strs(tles_paths: list[str]):
    return [str('"' + tle_path + '"') for tle_path in tles_paths]

rule update_omnetini:
    input:
        ini_template="omnetpp.ini.template",
        tles_paths=get_tles_paths()
    params:
        # as snakemake won't accept filepath strings containing quotes as input
        # but updateomnetini.pp requires them
        quoted_tles_paths= lambda wildcards, input: quote_strs(input.tles_paths)
    output:
        "omnetpp.ini"
    shell:
        "python3 /workspaces/ma-max-wendler/scripts/keplertraces/updateomnetini.py {input.ini_template} ./traces/ {params.quoted_tles_paths}"

def get_traces_dir(itrf=None):
    base_dir = config["traces_dir"].removesuffix("/")
    orekit_str = "_orekit" if config["use_orekit"] else ""
    itrf_str = "_itrf" if itrf else ""

    return base_dir + itrf_str + orekit_str + "/"

rule create_traces_v2:
    input:
        ini_path="omnetpp.ini",
        tles_path=lambda wildcards: glob.glob("tles/" + wildcards.constellation + "_*.txt")
    params:
        configname=lambda wildcards: expand("{optional_Debug}{constellation}-kepler", 
                                        optional_Debug="Debug-" if config["debug_mode"] else "",
                                        constellation=wildcards.constellation),
        itrf_option= lambda wildcards: "-i" if "itrf" in wildcards.traces_dir else "",
        orekit_option="-o" if config["use_orekit"] else ""
    output:
        "{traces_dir}/{constellation}_traces.done"
    shell:
        """
        python3 /workspaces/ma-max-wendler/scripts/keplertraces/create_traces.py {input.ini_path} {input.tles_path} {wildcards.traces_dir} -c {params.configname} {params.itrf_option} {params.orekit_option}
        touch {output}
        """

rule make_makefiles:
    input:
        "../../Makefile"
    output:
        "../../src/Makefile"
    shell:
        "cd ../../ && make makefiles"

rule build_space_veins_devcontainer:
    input:
        "../../Makefile",
        "cleanall.done"
    output:
        "../../bin/space_veins_run",
        temp("build_devcontainer.done")
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        cd ../../
        make makefiles
        bear --append -- make all -j{threads}
        cd examples/space_veins
        touch "build_devcontainer.done"
        """

rule build_space_veins_singularity:
    input:
        "../../Makefile",
        "cleanall.done"
    output:
        "../../bin/space_veins_run",
        temp("build_singularity.done")
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        make makefiles
        ucc make -j{threads} all
        make bin/space_veins_run
        touch "cleanall.done"
        """

rule cleanSpaceVeins:
    input:
        "../../Makefile",
        "../../src/Makefile"
    output:
        temp("cleanall.done")
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    threads:
        1
    shell:
        """
        cd ../../ &&
        make cleanall &&
        cd examples/space_veins &&
        touch "cleanall.done" 
        """

rule createRunmakerLogFile:
    output:
        "runs/{oppConfig}_runs.log"
    shell:
        "touch {output}"

rule createRunFile:
    input:
        "omnetpp.ini"
    output:
        "runs/{oppConfig}_runs.txt"
    # container:
    #    "../../singularity/singularity-space_veins.sif"
    shell:
        """
        echo '. ./run -u Cmdenv -c {wildcards.oppConfig} -r 1' > {output}
        """

rule createRunmakerFiles:
    input:
        expand("runs/{optional_Debug}{constellation}-{mobility}_runs.log", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"]),
        expand("runs/{optional_Debug}{constellation}-{mobility}_runs.txt", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"]),
    output:
        temp("runmaker.done")
    shell:
        "touch runmaker.done"

def get_const_from_config(config_str):
    config = config_str.replace("Debug-","")
    constellation = config.split("-")[0]
    return constellation

def get_trace_requirement(wildcards):
    if "kepler" in wildcards.oppConfig:
        return get_traces_dir() + get_const_from_config(wildcards.oppConfig) + "_traces.done"
    else: 
        return []

rule run:
    input:
        # only require trace files for Kepler-orbit-based runs
        # either traces/ or traces_orekit/ with use_orekit:true in config
        get_trace_requirement,
        logFile="runs/{oppConfig}_runs.log",
        runFile="runs/{oppConfig}_runs.txt"
    output:
        "runs/{oppConfig}_done.txt"
    threads:
        1
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    shell:
        """
        python3 ../../lib/runmaker/runmaker4.py --jobs={threads} -l {input.logFile} --loglines=200 {input.runFile} && touch {output}
        """

rule runAll:
    input:
        expand("runs/{optional_Debug}{constellation}-{mobility}_done.txt", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"])
    output:
        "runs/runall.done"
    shell:
        "touch runs/runall.done"

def format_coord_vectors(wildcards):
    if (wildcards.coordframe == "wgs84"):
        return ("--list -F " + "wgs84CoordLat:vector=wgs84CoordLat_vector" +
                                " -F wgs84CoordLon:vector=wgs84CoordLon_vector " +
                                " -F wgs84CoordAlt:vector=wgs84CoordAlt_vector")
    elif (wildcards.coordframe == "itrf"):
        return ("--list -F " + "itrfCoordX:vector=itrfCoordX_vector" +
                                " -F itrfCoordY:vector=itrfCoordY_vector" +
                                " -F itrfCoordZ:vector=itrfCoordZ_vector")
    else:
        raise ValueError(f"coordinate frame {wildcards.coordframe} is not supported for csv results")

def formatItervars(wildcards):
    i = ""
    for s in config["itervars"]:
        i += "-I " + s + " "
    return i

rule vec2csv:
    input:
        "runs/{oppConfig}_done.txt"
    output:
        "csv/vectors/{oppConfig}_{coordframe}_sorted.csv"
    params:
        itervars=formatItervars,
        vectors=format_coord_vectors,
        moduleRegex='^SatelliteExampleScenario\.leo',
        unsorted_path="csv/vectors/{oppConfig}_{coordframe}.csv"
    threads:
        1
    shell:
        """
        perl ../../lib/veins_scripts/eval/opp_vec2csv.pl -v -m emt -M {params.moduleRegex} {params.vectors} -A repetition {params.itervars} results/{wildcards.oppConfig}*.vec > {params.unsorted_path}
        python3 ../../scripts/time_sort_csv.py {params.unsorted_path}  
        rm {params.unsorted_path}
        """

def get_sat_mods_per_const():
    sat_modules_per_constellation = {}
    results = os.listdir("./results/")
    debug_mode_str = "Debug-" if config["debug_mode"] else ""
    for constellation in config["tles_prefixes"]:
        for res_fname in results:
            if res_fname.startswith(f"{debug_mode_str}{constellation}") and res_fname.endswith(".vec"):
                # parse satellite module names from .vec

                sat_mods = set()

                with open("./results/" + res_fname, "r") as vec_file:

                    for line in vec_file.readlines():
                        if "SatelliteExampleScenario.leo" in line:
                            sat_name = line.split(" ")[2]
                            sat_mods.add(sat_name)
                
                sat_modules_per_constellation[constellation] = sat_mods
    
    return sat_modules_per_constellation

def get_const_sat_mods(constellation: str):
    results = os.listdir("./results/")
    debug_mode_str = "Debug-" if config["debug_mode"] else ""
    sat_mods = set()
    for res_fname in results:
        if res_fname.startswith(f"{debug_mode_str}{constellation}") and res_fname.endswith(".vec"):
            # parse satellite module names from .vec

            with open("./results/" + res_fname, "r") as vec_file:

                for line in vec_file.readlines():
                    if "SatelliteExampleScenario.leo" in line:
                        sat_name = line.split(" ")[2]
                        sat_mods.add(sat_name)
    
    return sat_mods

def formatSatVecCsvFileNames():
    files = list()
    f = ""
    configs_per_constellation = {}
    for constellation in config["tles_prefixes"]:
        configs_per_constellation[constellation] = expand("{optional_Debug}{constellation}-{mobility}", 
                                                        optional_Debug="Debug-" if config["debug_mode"] else "" ,
                                                        constellation=[constellation],
                                                        mobility=config["mobilities"])

    # sat_mods_per_constellation = get_sat_mods_per_const()

    for c in configs_per_constellation.keys():
        # sat_mods = sat_mods_per_constellation[c]

            for vec in config["sat_vectors"]:
                f = "csv/vectors/" + c + "_" + config["sat_mod_regex_base"] + "_" + vec + ".csv"
                files.append(f)

    return files

def get_debug_str():
    return "Debug-" if config["debug_mode"] else ""

def format_constellation_satvec_csvnames(wildcards):
    config_name = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility 

    files = []

    for frame in config["coord_frames"]:
        if frame == "itrf" and wildcards.mobility == "kepler":
            continue
        f = "csv/vectors/" + config_name + "_" + frame + "_sorted.csv"
        files.append(f)
    
    return files

rule sat_vec_to_csv_constellation:
    input:
        "runs/" + get_debug_str() + "{constellation}-{mobility}_done.txt",
        format_constellation_satvec_csvnames
    output:
        "csv/" + get_debug_str() + "{constellation}-{mobility}_vecs.done"
    shell:
        "touch {output}"

def get_coord_inputs(wildcards):
    if (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler") and wildcards.coord_frame == "itrf":
        other_mobility = wildcards.mobility1 if wildcards.mobility2 == "kepler" else wildcards.mobility2
        return [get_traces_dir(True) + "{constellation}_traces.done",
                "csv/vectors/{constellation}-" + other_mobility + "_{coord_frame}_sorted.csv"]
    else:
        return ["csv/vectors/{constellation}-{mobility1}_{coord_frame}_sorted.csv",
                "csv/vectors/{constellation}-{mobility2}_{coord_frame}_sorted.csv"]

def get_traces_dir_from_donefile(donefile_path):
    donefile_name = donefile_path.split("/")[-1]
    constellation = donefile_name.split("_")[0]
    all_traces_dir = donefile_path.removesuffix(donefile_name)
    for file_or_dir_name in os.listdir(all_traces_dir):
        if file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"):
            return all_traces_dir + file_or_dir_name
    error_str = f"No directory for constellation {constellation} was found!"
    raise NameError(error_str)

rule calc_pos_diffs:
    input:
        trace_done_or_csvs=get_coord_inputs
    output:
        "csv/pos_diff/" + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    params:
        traces_dir_or_csv = lambda wildcards, input: input.trace_done_or_csvs[0] if input.trace_done_or_csvs[0].endswith(".csv") else get_traces_dir_from_donefile(input.trace_done_or_csvs[0]),
        debug_option = "-d" if config["debug_mode"] else ""
    shell:
        "python3 ../../scripts/plots/positional_differences.py {params.traces_dir_or_csv} {input.trace_done_or_csvs[1]} {wildcards.constellation} {wildcards.coord_frame} -c {params.debug_option} > {output}"

rule plot_pos_diffs:
    input:
        in_csv="csv/pos_diff/" + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    output:
        "plots/pos_diff/"+ get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_{leo_modname}_distances.png"
    shell:
        "python3 ../../scripts/plots/plot_differences.py {input.in_csv} {wildcards.leo_modname} /workspaces/ma-max-wendler/examples/space_veins/plots/pos_diff"

rule satmod_csv:
    input:
        "csv/vectors/{opp_config}_{coord_frame}_sorted.csv"
    output:
        "csv/vectors/satmod/{opp_config}_{coord_frame}_sorted_{leo_modname}.csv"
    shell:
        "python3 ../../scripts/plots/to_sat_csv.py {input} {wildcards.leo_modname} > {output}"


def get_satmod_csv_paths_or_traces_done(wildcards, same_config=True):
    leo_modnames = wildcards.leo_modnames.split("-")

    if same_config:

        if "kepler" in wildcards.opp_config and wildcards.coord_frame == "itrf":
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = get_const_from_config(wildcards.opp_config)
            return [traces_dir + constellation + "_traces.done"]

        # no traces required, can use simulation results
        else:
            base_path = "csv/vectors/satmod/" + wildcards.opp_config + "_" + wildcards.coord_frame + "_sorted_"
            return [(base_path + modname + ".csv") for modname in leo_modnames]

    # one config might be kepler, coord frame might be itrf
    else:

        # return path of {constellation}_traces.done and paths of csvs of other mobility
        if wildcards.coord_frame == "itrf" and (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler"):
            non_kepler_mob = wildcards.mobility1 if wildcards.mobility1 != "kepler" else wildcards.mobility2
            non_kepler_mob_config_str = get_debug_str() + wildcards.constellation + "-" + non_kepler_mob
            non_kepler_mob_base_path = "csv/vectors/satmod/" + non_kepler_mob_config_str + "_" + wildcards.coord_frame + "_sorted_"
            
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            traces_done_path = traces_dir + wildcards.constellation + "_traces.done"

            return [(non_kepler_mob_base_path + modname + ".csv") for modname in leo_modnames] + [traces_done_path]

        # only return csv paths
        else:
            mob1_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility1
            mob2_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility2
            mob1_base_path = "csv/vectors/satmod/" + mob1_config_str + "_" + wildcards.coord_frame + "_sorted_"
            mob2_base_path = "csv/vectors/satmod/" + mob2_config_str + "_" + wildcards.coord_frame + "_sorted_"
            return [(mob1_base_path + modname + ".csv") for modname in leo_modnames] + [(mob2_base_path + modname + ".csv") for modname in leo_modnames]

def get_trace_paths(wildcards, input, same_config=True):
    leo_modnames = wildcards.leo_modnames.split("-")

    if same_config:
        if "kepler" in wildcards.opp_config and wildcards.coord_frame == "itrf":
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = get_const_from_config(wildcards.opp_config)
            const_traces_dir = traces_dir + filter(lambda file_or_dir_name: file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"),
                                                    os.listdir(traces_dir)).__next__() + "/"
            
            modname_to_satname_dict = None
            with open(const_traces_dir + "modname_to_satname_dict.json", "r") as dict_f:
                modname_to_satname_dict = json.load(dict_f)
            satnames = [modname_to_satname_dict[modname] for modname in leo_modnames]

            return [(const_traces_dir + satname + ".trace") for satname in satnames]
        # no traces required
        else:
            return []
    
    else:

        if wildcards.coord_frame == "itrf" and (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler"):
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = wildcards.constellation
            const_traces_dir = traces_dir + filter(lambda file_or_dir_name: file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"),
                                                    os.listdir(traces_dir)).__next__() + "/"
            
            modname_to_satname_dict = None
            with open(const_traces_dir + "modname_to_satname_dict.json", "r") as dict_f:
                modname_to_satname_dict = json.load(dict_f)
            satnames = [modname_to_satname_dict[modname] for modname in leo_modnames]

            return [(const_traces_dir + satname + ".trace") for satname in satnames]
        
        else:
            return []

def filter_csv_paths(path_list):
    return list(filter(lambda path: path.endswith(".csv"), path_list))

rule plot_orbs_of_mobility:
    input:
        coord_paths=get_satmod_csv_paths_or_traces_done
    output:
        "plots/orbs/mobility/{opp_config}_{coord_frame}_{leo_modnames}.html"
    params:
        csv_paths= lambda wildcards, input: quote_strs(filter_csv_paths(input.coord_paths)),
        csv_option= lambda wildcards, input: "-c" if len(filter_csv_paths(input.coord_paths)) > 0 else "",
        trace_paths= lambda wildcards, input: quote_strs(get_trace_paths(wildcards, input)),
        trace_option= lambda wildcards, input: "-t" if len(get_trace_paths(wildcards, input)) > 0 else ""
    shell:
        """
        python3 ../../scripts/plots/plot_orbs.py {params.csv_option} {params.csv_paths} {params.trace_option} {params.trace_paths} -o '{output}' -e
        """

rule plot_orbs_of_mobilities:
    input:
        coord_paths= lambda wildcards: get_satmod_csv_paths_or_traces_done(wildcards, False)
    output:
        "plots/orbs/mobilities/" + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_{leo_modnames}.html"
    params:
        csv_paths= lambda wildcards, input: quote_strs(filter_csv_paths(input.coord_paths)),
        trace_paths= lambda wildcards, input: quote_strs(get_trace_paths(wildcards, input, False))
    shell:
        "python3 ../../scripts/plots/plot_orbs.py -c {params.csv_paths} -t {params.trace_paths} -o '{output}' -e"