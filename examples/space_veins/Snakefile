# SPDX-FileCopyrightText: 2023 Mario Franke <research@m-franke.net>
#
# SPDX-License-Identifier: GPL-2.0-or-later

configfile: "smk.config.yaml"
import os
import glob

#### SINGULARITY CONTAINER ####

rule buildContainer:
    input:
        "../../singularity/singularity-space_veins.def"
    output:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        singularity build --fakeroot {output} {input}
        """

rule shell:
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        bash
        """

#### DEPENDENCIES ####

rule buildSpaceVeins:
    input:
        "../../Makefile"
    output:
        "../../bin/space_veins_run"
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        make makefiles
        ucc make -j{threads} all
        make bin/space_veins_run
        """

rule cleanSpaceVeins:
    input:
        "../../Makefile"
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        1
    shell:
        """
        make cleanall
        """

rule init_conda_bash:
    output:
        "../../singularity/conda_initialized.txt"
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        conda init
        echo "conda activate /opt/.conda" >> .bashrc
        touch examples/space_veins/{output}
        """

rule install_conda_pip_deps:
    input:
        "../../singularity/conda_initialized.txt"
    output:
        "../../singularity/conda_pip_deps_done.txt"
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        bash -i -c "pip install --no-cache-dir --upgrade pip && pip install --no-cache-dir tle-tools"
        touch examples/space_veins/{output}
        """

rule download_orekit_data:
    output:
        "orekit-data.zip"
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        """
        cd examples/space_veins/
        bash -i -c "python3 -c 'from orekit.pyhelpers import download_orekit_data_curdir;download_orekit_data_curdir()'"
        """
rule get_modnames:
    input:
        script="../../scripts/statistics/get_modnames.py",
    output:
        "tles/{constellation}_modnames"
    params:
        tles_path=lambda wildcards: "tles/" + list(filter(lambda fname: fname.startswith(wildcards.constellation) and fname.endswith(".txt"), os.listdir("tles/")))[0]
    shell:
        "python3 {input.script} {params.tles_path} {output}"

rule setup_modnames_files:
    input:
        expand("tles/{constellation}_modnames", constellation=config["constellations"])
    output:
        "tles/modnames.done"
    shell:
        "touch {output}"

rule finish_dep_setup:
    input:
        "../../singularity/conda_pip_deps_done.txt",
        "tles/modnames.done",
        "../../bin/space_veins_run",
        "orekit-data.zip"

def get_const_sat_mods(constellation: str):
    """
    Returns module names of satellites of a constellation, parsed from the according TLEs list and converted with satname_to_modname().
    """
    with open("tles/" + constellation + "_modnames", "r") as name_f:
        modnames = [mn.removesuffix("\n") for mn in name_f.readlines()]
    
    return modnames

#### FUNCTIONS FOR READING PARAM FILES / SMK CONFIG ####

def quote_strs(strs: list[str]):
    """
    Puts quotes around given strings, as snakemake requires path strings without additional quotes,
    while python scripts occasionally required quoted paths.
    """
    return ['"' + in_str + '"' for in_str in strs]

def get_tles_paths():
    """
    Returns all paths of TLEs lists used according to the current snakemake configuration (-> constellations).

    Used by rule 'update_omnetini'
    """
    tles_fname_prefixes = config["constellations"]
    tles_fpaths = [] 
    
    for fname in os.listdir("./tles/"):
        if fname.split("_")[0] in tles_fname_prefixes and fname.endswith(".txt"):
            tles_fpaths.append(f'{"tles/" + fname}')
    
    return sorted(tles_fpaths)

def get_avg_sgp4_altitudes_paths():

    constellations = sorted(config["constellations"])
    avg_sgp4_altitudes_dir = "csv/avg_alt/" + config["location"] + "/"
    if os.path.isdir(avg_sgp4_altitudes_dir) and config["use_avg_sgp4_altitudes"]:
        avg_alt_fnames = list(filter(lambda fname: fname.split("-")[0] in constellations, sorted(os.listdir( avg_sgp4_altitudes_dir ))))
        
        avg_sgp4_altitudes_paths = []
        for c in constellations:
            path = None
            for fname in avg_alt_fnames:
                if c in fname:
                    path = avg_sgp4_altitudes_dir + fname
            if path:
                avg_sgp4_altitudes_paths.append(path)
            else:
                avg_sgp4_altitudes_paths.append("None")

        return avg_sgp4_altitudes_paths
    else:
        return ["None"] * len(constellations)

def get_debug_str():
    """
    Function for optionally including 'Debug-' prefix for simulation configuration names,
    when debug_mode is set to true in snakemake config.
    """
    return "Debug-" if config["debug_mode"] else ""

#### SETTING UP & RUNNING THE SIMULATION ####

rule update_nod_xml:
    input:
        script="../../scripts/update_nod_xml.py",
        nod_template="two-nodes.nod.xml.template"
    output:
        "two-nodes.nod.xml"
    params:
        location_str=lambda wildcards: config["locations_xml"][config["location"]]
    shell:
        "python3 {input.script} {input.nod_template} '{params.location_str}' {output}"

rule update_net_xml:
    input:
        script="../../scripts/createRoadNetwork.sh",
        nod="two-nodes.nod.xml",
        edg="two-nodes.edg.xml"
    container:
        "../../singularity/singularity-space_veins.sif"
    output:
        "two-nodes.net.xml"
    shell:
        """
        cd examples/space_veins
        bash {input.script} {input.nod} {input.edg} {output}
        """

rule update_omnetini:
    """
    Adds debug and non-debug configuration generated from the template at ../../scripts/keplertraces/config_template.txt,
    for the different mobilities and constellation-dependent TLEs list files, trace directories and simulation start times.
    omnetpp.ini.template is overwritten after [Config Debug] section. omnetpp.ini.template contains example configs after [Config Debug] section.
    """
    input:
        script="../../scripts/keplertraces/updateomnetini.py",
        ini_template="omnetpp.ini.template",
        conf_template="../../scripts/keplertraces/config_template.txt",
        tles_paths=get_tles_paths()
    params:
        # as snakemake won't accept filepath strings containing quotes as input
        # but call of python scripts requires them
        quoted_tles_paths= lambda wildcards, input: quote_strs(input.tles_paths),
        sim_time_limit = config["sim-time-limit"],
        avg_sgp4_altitudes_paths = quote_strs(get_avg_sgp4_altitudes_paths()),
        location = config["location"]
    output:
        "omnetpp.ini"
    shell:
        """python3 {input.script} {input.ini_template} {input.conf_template} traces/ {params.sim_time_limit} {params.location} --tles_paths {params.quoted_tles_paths} --avg_sgp4_altitudes_paths {params.avg_sgp4_altitudes_paths}"""

rule create_traces:
    """
    Creates ITRF traces of a constellation for either the normal or the debug configuration in omnetpp.ini,
    from which parameters are derived.
    """
    input:
        script="../../scripts/keplertraces/create_traces.py",
        ini_path="omnetpp.ini",
        tles_path=lambda wildcards: glob.glob("tles/" + wildcards.constellation + "_*.txt")
    container:
        "../../singularity/singularity-space_veins.sif"
    benchmark:
        "benchmarks/{constellation}_traces.benchmark.txt"
    params:
        configname=lambda wildcards: expand("{optional_Debug}{constellation}-kepler", 
                                        optional_Debug="Debug-" if config["debug_mode"] else "",
                                        constellation=wildcards.constellation),
    output:
        "traces/{constellation}_traces.done"
    shell:
        """
        cd examples/space_veins
        bash -i -c "python3 {input.script} {input.ini_path} {input.tles_path} traces/ -c {params.configname} -i -o"
        date +%Y%m%d%H%M%S > {output}
        """

def get_trace_requirement(wildcards):
    """
    Returns traces as input requirement for rule createRunFile only for Kepler configurations. 
    """
    if "kepler" in wildcards.oppConfig:
        config_str = wildcards.oppConfig
        config = config_str.replace("Debug-","")
        constellation = config.split("-")[0]
        return "traces/" + constellation + "_traces.done"
    else: 
        return []

rule createRunFile:
    """
    Creates run files to run simulations with runmaker
    """
    input:
        # only require trace files for Kepler-orbit-based runs
        # ---
        # placed here instead of in rule 'run' so that run file is regenerated with more recent traces
        # otherwise, run file still has run marked as 'd', done
        get_trace_requirement,
        "omnetpp.ini"
    output:
        "runs/{oppConfig}_runs.txt"
    container:
        "../../singularity/singularity-space_veins.sif"
    shell:
        #"""
        #    echo '. ./run -u Cmdenv -c {wildcards.oppConfig} -r 1' > {output}
        #"""
        """
        cd examples/space_veins
        perl ../../lib/veins_scripts/running/generateRunsFile.pl {wildcards.oppConfig} > {output}
        """

rule createRunmakerLogFile:
    """
    Creates .log file for running simulations with runmaker.
    """
    output:
        "runs/{oppConfig}_runs.log"
    shell:
        "touch {output}"

rule run:
    """
    Runs OMNeT++ simulation for a configuration from omnetpp.ini.
    """
    input:
        net_xml="two-nodes.net.xml",
        logFile="runs/" + get_debug_str() + "{const_comp}-{mobility}_runs.log",
        runFile="runs/" + get_debug_str() + "{const_comp}-{mobility}_runs.txt"
    output:
        "runs/" + get_debug_str() + "{const_comp}-{mobility}_done.txt"
    threads:
        1
    benchmark:
        "benchmarks/{const_comp}-{mobility}_run.benchmark.txt"
    container:
       "../../singularity/singularity-space_veins.sif"
    shell:
        """
        cd examples/space_veins
        ../../lib/veins/bin/veins_launchd -vv -d
        python3 ../../lib/runmaker/runmaker4.py --jobs={threads} -l {input.logFile} --loglines=200 {input.runFile} 
        date +%Y%m%d%H%M%S > {output}
        """

#### RUNTIME METRICS ####
# calculating total runtime of rules create_traces (Kepler mobility only) and run

def get_const_comp_benchmarks(wildcards):
    constellation_components = config["constellation_compositions"][wildcards.constellation]
    benchmark_paths = []
    benchmark_paths += expand("benchmarks/{const_comp}-{mobility}_run.benchmark.txt", const_comp=constellation_components, mobility=wildcards.mobility)
    if wildcards.mobility == "kepler":
        benchmark_paths += expand("benchmarks/{const_comp}_traces.benchmark.txt", const_comp=constellation_components)
    return benchmark_paths

rule calc_runtime:
    input:
        script="../../scripts/statistics/runtime_from_benchmarks.py",
        benchmarks=get_const_comp_benchmarks
    output:
        "stats/runtime/{constellation}_{mobility}_runtime.txt"
    shell:
        "python3 {input.script} {output} {input.benchmarks}"

#### EXTRACTING COORDINATE DATA ####

def format_coord_vectors(wildcards):
    """
    Determines coordinate vectors that should be written from simulation results to a CSV by "../../lib/veins_scripts/eval/opp_vec2csv.pl",
    depending on coordinate frame requested for rule vec2csv.
    """
    if (wildcards.coordframe == "wgs84"):
        return ("--list -F " + "wgs84CoordLat:vector=wgs84CoordLat_vector" +
                                " -F wgs84CoordLon:vector=wgs84CoordLon_vector " +
                                " -F wgs84CoordAlt:vector=wgs84CoordAlt_vector")
    elif (wildcards.coordframe == "itrf"):
        return ("--list -F " + "itrfCoordX:vector=itrfCoordX_vector" +
                                " -F itrfCoordY:vector=itrfCoordY_vector" +
                                " -F itrfCoordZ:vector=itrfCoordZ_vector")
    elif (wildcards.coordframe == "omnet"):
        return ("--list -F " + "omnetCoordX:vector=omnetCoordX_vector" +
                                " -F omnetCoordY:vector=omnetCoordY_vector" +
                                " -F omnetCoordZ:vector=omnetCoordZ_vector")
    elif (wildcards.coordframe == "teme"):
        return ("--list -F " + "temeCoordX:vector=temeCoordX_vector" +
                                " -F temeCoordY:vector=temeCoordY_vector" +
                                " -F temeCoordZ:vector=temeCoordZ_vector")
    else:
        raise ValueError(f"coordinate frame {wildcards.coordframe} is not supported for csv results")

rule vec2csv:
    """
    Parses coordinate vectors from simulation results to a 3D-coordinate CSV for specified coordinate frame.
    Uses ../../scripts/time_sort_csv.py to sort after (1) satellite module and (2) simulation time.
    """
    input:
        "runs/{oppConfig}_done.txt",
        sort_script="../../scripts/time_sort_csv.py"
    output:
        "csv/vector_components/{location}_{oppConfig}_{coordframe}_sorted.csv"
    params:
        vectors=format_coord_vectors,
        moduleRegex='^SatelliteExampleScenario\.leo',
        unsorted_path="csv/vector_components/{location}_{oppConfig}_{coordframe}.csv",
        vec_file = lambda wildcards: "results/" + wildcards.oppConfig + "-warmupPeriod=15,simTimeLimit=" + str(config["sim-time-limit"]) + "," + "location=" + config["location"] + "*.vec"
    threads:
        1
    shell:
        """
        perl ../../lib/veins_scripts/eval/opp_vec2csv.pl -v -m emt -M {params.moduleRegex} {params.vectors} {params.vec_file} > {params.unsorted_path}
        python3 {input.sort_script} {params.unsorted_path}  
        rm {params.unsorted_path}
        """

def get_csvs_to_compose(wildcards):
    constellation = wildcards.composed_constellation
    const_components = config["constellation_compositions"][constellation]
    in_csvs = []
    for const_comp in const_components:
        in_csvs.append(f"csv/vector_components/{wildcards.location}_{const_comp}-{wildcards.mobility}_{wildcards.coordframe}_sorted.csv")
    return in_csvs

rule compose_pos_csvs:
    input:
        script="../../scripts/utility/compose_pos_csvs.py",
        in_csvs=get_csvs_to_compose
    output:
        "csv/vectors/{location}_{composed_constellation}-{mobility}_{coordframe}_sorted.csv"
    shell:
        "python3 {input.script} {output} {input.in_csvs}"