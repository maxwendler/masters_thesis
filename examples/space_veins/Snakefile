import os
import glob
import json
import sys
sys.path.append(os.path.join(sys.path[0],"..","..","scripts", "plots"))
from satname_to_modname import satname_to_modname
sys.path.append(os.path.join(sys.path[0],"..","..",".conda", "lib", "python3.10", "site-packages"))
sys.path.append(os.path.join(sys.path[0],"..","..","scripts", "keplertraces"))
from tleparse import read

configfile: "smk.config.yaml"

def get_tles_paths():
    tles_fname_prefixes = config["tles_prefixes"]
    tles_fpaths = [] 
    
    for fname in os.listdir("./tles/"):
        if fname.split("_")[0] in tles_fname_prefixes:
            tles_fpaths.append(f'{"tles/" + fname}')
    
    return tles_fpaths

def quote_strs(tles_paths: list[str]):
    return [str('"' + tle_path + '"') for tle_path in tles_paths]

def get_traces_dir(itrf=None):
    base_dir = config["traces_dir"].removesuffix("/")
    orekit_str = "_orekit" if config["use_orekit"] else ""
    itrf_str = "_itrf" if itrf else ""

    return base_dir + itrf_str + orekit_str + "/"

rule update_omnetini:
    input:
        "../../scripts/keplertraces/updateomnetini.py",
        ini_template="omnetpp.ini.template",
        tles_paths=get_tles_paths()
    params:
        # as snakemake won't accept filepath strings containing quotes as input
        # but updateomnetini.py requires them
        quoted_tles_paths= lambda wildcards, input: quote_strs(input.tles_paths),
        traces_dir = get_traces_dir(True)
    output:
        "omnetpp.ini"
    shell:
        "python3 ../../scripts/keplertraces/updateomnetini.py {input.ini_template} {params.traces_dir} {params.quoted_tles_paths}"

rule create_traces:
    input:
        "../../scripts/keplertraces/create_traces.py",
        ini_path="omnetpp.ini",
        tles_path=lambda wildcards: glob.glob("tles/" + wildcards.constellation + "_*.txt")
    params:
        configname=lambda wildcards: expand("{optional_Debug}{constellation}-kepler", 
                                        optional_Debug="Debug-" if config["debug_mode"] else "",
                                        constellation=wildcards.constellation),
        itrf_option= lambda wildcards: "-i" if "itrf" in wildcards.traces_dir else "",
        orekit_option="-o" if config["use_orekit"] else ""
    output:
        "{traces_dir}/{constellation}_traces.done"
    shell:
        """
        python3 ../../scripts/keplertraces/create_traces.py {input.ini_path} {input.tles_path} {wildcards.traces_dir} -c {params.configname} {params.itrf_option} {params.orekit_option}
        date +%Y%m%d%H%M%S > {output}
        """

rule make_makefiles:
    input:
        "../../Makefile"
    output:
        "../../src/Makefile"
    shell:
        "cd ../../ && make makefiles"

rule build_space_veins_devcontainer:
    input:
        "../../Makefile",
        "cleanall.done"
    output:
        "../../bin/space_veins_run",
        temp("build_devcontainer.done")
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        cd ../../
        make makefiles
        bear --append -- make all -j{threads}
        cd examples/space_veins
        touch "build_devcontainer.done"
        """

rule build_space_veins_singularity:
    input:
        "../../Makefile",
        "cleanall.done"
    output:
        "../../bin/space_veins_run",
        temp("build_singularity.done")
    container:
        "../../singularity/singularity-space_veins.sif"
    threads:
        workflow.cores
    shell:
        """
        make makefiles
        ucc make -j{threads} all
        make bin/space_veins_run
        touch "cleanall.done"
        """

rule cleanSpaceVeins:
    input:
        "../../Makefile",
        "../../src/Makefile"
    output:
        temp("cleanall.done")
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    threads:
        1
    shell:
        """
        cd ../../ &&
        make cleanall &&
        cd examples/space_veins &&
        touch "cleanall.done" 
        """

rule createRunmakerLogFile:
    output:
        "runs/{oppConfig}_runs.log"
    shell:
        "touch {output}"

def get_trace_requirement(wildcards):
    if "kepler" in wildcards.oppConfig:
        return get_traces_dir(True) + get_const_from_config(wildcards.oppConfig) + "_traces.done"
    else: 
        return []

rule createRunFile:
    input:
        # only require trace files for Kepler-orbit-based runs
        # either traces/ or traces_orekit/ with use_orekit:true in config
        # ---
        # placed here instead of in rule 'run' so that run file is regenerated with more recent traces
        # otherwise, run file still has run marked as 'd', done
        get_trace_requirement,
        "omnetpp.ini"
    output:
        "runs/{oppConfig}_runs.txt"
    # container:
    #    "../../singularity/singularity-space_veins.sif"
    shell:
        """
        echo '. ./run -u Cmdenv -c {wildcards.oppConfig} -r 1' > {output}
        """

rule createRunmakerFiles:
    input:
        expand("runs/{optional_Debug}{constellation}-{mobility}_runs.log", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"]),
        expand("runs/{optional_Debug}{constellation}-{mobility}_runs.txt", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"]),
    output:
        temp("runmaker.done")
    shell:
        "touch runmaker.done"

def get_const_from_config(config_str):
    config = config_str.replace("Debug-","")
    constellation = config.split("-")[0]
    return constellation

rule run:
    input:
        logFile="runs/{oppConfig}_runs.log",
        runFile="runs/{oppConfig}_runs.txt"
    output:
        "runs/{oppConfig}_done.txt"
    threads:
        1
    #container:
    #    "../../singularity/singularity-space_veins.sif"
    shell:
        """
        python3 ../../lib/runmaker/runmaker4.py --jobs={threads} -l {input.logFile} --loglines=200 {input.runFile} 
        date +%Y%m%d%H%M%S > {output}
        """

rule runAll:
    input:
        expand("runs/{optional_Debug}{constellation}-{mobility}_done.txt", 
                optional_Debug="Debug-" if config["debug_mode"] else "" ,
                constellation=config["tles_prefixes"],
                mobility=config["mobilities"])
    output:
        "runs/runall.done"
    shell:
        "touch runs/runall.done"

def format_coord_vectors(wildcards):
    if (wildcards.coordframe == "wgs84"):
        return ("--list -F " + "wgs84CoordLat:vector=wgs84CoordLat_vector" +
                                " -F wgs84CoordLon:vector=wgs84CoordLon_vector " +
                                " -F wgs84CoordAlt:vector=wgs84CoordAlt_vector")
    elif (wildcards.coordframe == "itrf"):
        return ("--list -F " + "itrfCoordX:vector=itrfCoordX_vector" +
                                " -F itrfCoordY:vector=itrfCoordY_vector" +
                                " -F itrfCoordZ:vector=itrfCoordZ_vector")
    else:
        raise ValueError(f"coordinate frame {wildcards.coordframe} is not supported for csv results")

def formatItervars(wildcards):
    i = ""
    for s in config["itervars"]:
        i += "-I " + s + " "
    return i

def get_orekit_path_option():
    if config["use_orekit"]:
        return "orekit/"
    else:
        return "no-orekit/"

rule vec2csv:
    input:
        "runs/{oppConfig}_done.txt",
        "../../scripts/time_sort_csv.py"
    output:
        "csv/" + "vectors/" + get_orekit_path_option() + "{oppConfig}_{coordframe}_sorted.csv"
    params:
        itervars=formatItervars,
        vectors=format_coord_vectors,
        moduleRegex='^SatelliteExampleScenario\.leo',
        unsorted_path="csv/vectors/" + get_orekit_path_option() + "{oppConfig}_{coordframe}.csv"
    threads:
        1
    shell:
        """
        perl ../../lib/veins_scripts/eval/opp_vec2csv.pl -v -m emt -M {params.moduleRegex} {params.vectors} -A repetition {params.itervars} results/{wildcards.oppConfig}*.vec > {params.unsorted_path}
        python3 ../../scripts/time_sort_csv.py {params.unsorted_path}  
        rm {params.unsorted_path}
        """

def get_const_sat_mods(constellation: str):

    const_tles_fname = filter( lambda tles_path: tles_path.startswith(constellation), os.listdir("./tles/")).__next__()
    tles = read("./tles/" + const_tles_fname)

    sat_mods = set()
    for tle in tles:
        sat_mods.add( satname_to_modname(tle.name) )
    
    return sat_mods

def get_debug_str():
    return "Debug-" if config["debug_mode"] else ""

def format_constellation_satvec_csvnames(wildcards):
    config_name = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility 

    files = []

    for frame in config["coord_frames"]:
        #currently, use all frames, as poliastro itrf traces are used as simulation input
        #if frame == "itrf" and wildcards.mobility == "kepler":
        #    continue
        f = "csv/vectors/" + get_orekit_path_option() + config_name + "_" + frame + "_sorted.csv"
        files.append(f)
    
    return files

rule sat_vec_to_csv_constellation:
    input:
        "runs/" + get_debug_str() + "{constellation}-{mobility}_done.txt",
        format_constellation_satvec_csvnames
    output:
        "csv/" + get_orekit_path_option() + get_debug_str() + "{constellation}-{mobility}_vecs.done"
    shell:
        "touch {output}"

def get_coord_inputs(wildcards):
    # code below only use for wgs84 traces as simulation inputs
    
    #if (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler") and wildcards.coord_frame == "itrf":
    #    other_mobility = wildcards.mobility1 if wildcards.mobility2 == "kepler" else wildcards.mobility2
    #    return [get_traces_dir(True) + "{constellation}_traces.done",
    #            "csv/vectors/{constellation}-" + other_mobility + "_{coord_frame}_sorted.csv"]
    
    #else:
        return ["csv/vectors/" + get_orekit_path_option() + "{constellation}-{mobility1}_{coord_frame}_sorted.csv",
                "csv/vectors/" + get_orekit_path_option() + "{constellation}-{mobility2}_{coord_frame}_sorted.csv"]

def get_traces_dir_from_donefile(donefile_path):
    donefile_name = donefile_path.split("/")[-1]
    constellation = donefile_name.split("_")[0]
    all_traces_dir = donefile_path.removesuffix(donefile_name)
    for file_or_dir_name in os.listdir(all_traces_dir):
        if file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"):
            return all_traces_dir + file_or_dir_name
    error_str = f"No directory for constellation {constellation} was found!"
    raise NameError(error_str)

rule calc_pos_diffs:
    input:
        "../../scripts/plots/positional_differences.py",
        trace_done_or_csvs=get_coord_inputs
    output:
        "csv/pos_diff/" + get_orekit_path_option() + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    params:
        traces_dir_or_csv = lambda wildcards, input: input.trace_done_or_csvs[0] if input.trace_done_or_csvs[0].endswith(".csv") else get_traces_dir_from_donefile(input.trace_done_or_csvs[0]),
    shell:
        "python3 ../../scripts/plots/positional_differences.py {params.traces_dir_or_csv} {input.trace_done_or_csvs[1]} {wildcards.coord_frame} -c > {output}"

rule plot_pos_diffs:
    input:
        "../../scripts/plots/plot_differences.py",
        in_csv="csv/pos_diff/"+ get_orekit_path_option() + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    output:
        "plots/pos_diff/" + get_orekit_path_option() + "{constellation}/"+ get_debug_str() + "{coord_frame}_{mobility1}-{mobility2}_{leo_modname}_distances.png"
    shell:
        "python3 ../../scripts/plots/plot_differences.py {input.in_csv} '{wildcards.leo_modname}' '{output}'"

rule plot_pos_diffs_ecdf:
    input:
        "../../scripts/plots/plot_differences_ecdf.py",
        in_csv="csv/pos_diff/" + get_orekit_path_option() + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    output:
        "plots/pos_diff/"+ get_orekit_path_option() +"{constellation}/"+ get_debug_str() + "{coord_frame}_{mobility1}-{mobility2}_{leo_modname}_distances_ecdf.png"
    shell:
        "python3 ../../scripts/plots/plot_differences_ecdf.py {input.in_csv} '{wildcards.leo_modname}' '{output}'"

rule plot_pos_diffs_both:
    input:
        "../../scripts/plots/plot_differences_both.py",
        in_csv="csv/pos_diff/" + get_orekit_path_option() + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_distances.csv"
    output:
        "plots/pos_diff/" + get_orekit_path_option() + "{constellation}/"+ get_debug_str() + "{coord_frame}_{mobility1}-{mobility2}_{leo_modname}_distances_both.png"
    shell:
        "python3 ../../scripts/plots/plot_differences_both.py {input.in_csv} '{wildcards.leo_modname}' '{output}'"

def get_const_pos_diff_paths(wildcards):
    return expand("plots/pos_diff/"+ get_orekit_path_option()+ "{constellation}/" + get_debug_str() + "{coord_frame}_{mobility1}-{mobility2}_{leo_modname}_distances_both.png",
                constellation=wildcards.constellation, 
                coord_frame=wildcards.coord_frame, 
                mobility1=wildcards.mobility1, 
                mobility2=wildcards.mobility2,
                leo_modname=get_const_sat_mods(wildcards.constellation))

rule plot_const_pos_diffs:
    input:
        get_const_pos_diff_paths
    output:
        "plots/pos_diff/" + get_orekit_path_option() + "{constellation}/" + get_debug_str() + "{coord_frame}_{mobility1}-{mobility2}_distances.done"
    shell:
        "touch {output}"

rule satmod_csv:
    input:
        "../../scripts/plots/to_sat_csv.py",
        in_csv="csv/vectors/" + get_orekit_path_option() + "{opp_config}_{coord_frame}_sorted.csv"
    output:
        "csv/vectors/" + get_orekit_path_option() + "satmod/{opp_config}_{coord_frame}_sorted_{leo_modname}.csv"
    shell:
        "python3 ../../scripts/plots/to_sat_csv.py {input.in_csv} {wildcards.leo_modname} > {output}"

def get_satmod_csv_paths_or_traces_done(wildcards, same_config=True):
    leo_modnames = wildcards.leo_modnames.split("-")

    if same_config:

        if "kepler" in wildcards.opp_config and wildcards.coord_frame == "itrf":
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = get_const_from_config(wildcards.opp_config)
            return [traces_dir + constellation + "_traces.done"]

        # no traces required, can use simulation results
        else:
            base_path = "csv/vectors/satmod/" + wildcards.opp_config + "_" + wildcards.coord_frame + "_sorted_"
            return [(base_path + modname + ".csv") for modname in leo_modnames]

    # one config might be kepler, coord frame might be itrf
    else:

        # return path of {constellation}_traces.done and paths of csvs of other mobility
        if wildcards.coord_frame == "itrf" and (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler"):
            non_kepler_mob = wildcards.mobility1 if wildcards.mobility1 != "kepler" else wildcards.mobility2
            non_kepler_mob_config_str = get_debug_str() + wildcards.constellation + "-" + non_kepler_mob
            non_kepler_mob_base_path = "csv/vectors/satmod/" + non_kepler_mob_config_str + "_" + wildcards.coord_frame + "_sorted_"
            
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            traces_done_path = traces_dir + wildcards.constellation + "_traces.done"

            return [(non_kepler_mob_base_path + modname + ".csv") for modname in leo_modnames] + [traces_done_path]

        # only return csv paths
        else:
            mob1_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility1
            mob2_config_str = get_debug_str() + wildcards.constellation + "-" + wildcards.mobility2
            mob1_base_path = "csv/vectors/satmod/" + mob1_config_str + "_" + wildcards.coord_frame + "_sorted_"
            mob2_base_path = "csv/vectors/satmod/" + mob2_config_str + "_" + wildcards.coord_frame + "_sorted_"
            return [(mob1_base_path + modname + ".csv") for modname in leo_modnames] + [(mob2_base_path + modname + ".csv") for modname in leo_modnames]

def get_trace_paths(wildcards, same_config=True):
    leo_modnames = wildcards.leo_modnames.split("-")

    if same_config:
        if "kepler" in wildcards.opp_config and wildcards.coord_frame == "itrf":
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = get_const_from_config(wildcards.opp_config)
            const_traces_dir = traces_dir + filter(lambda file_or_dir_name: file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"),
                                                    os.listdir(traces_dir)).__next__() + "/"
            
            modname_to_satname_dict = None
            with open(const_traces_dir + "modname_to_satname_dict.json", "r") as dict_f:
                modname_to_satname_dict = json.load(dict_f)
            satnames = [modname_to_satname_dict[modname] for modname in leo_modnames]

            return [(const_traces_dir + satname + ".trace") for satname in satnames]
        # no traces required
        else:
            return []
    
    else:

        if wildcards.coord_frame == "itrf" and (wildcards.mobility1 == "kepler" or wildcards.mobility2 == "kepler"):
            orekit_str = "_orekit" if config["use_orekit"] else ""
            traces_dir = "traces_itrf" + orekit_str + "/"
            constellation = wildcards.constellation
            const_traces_dir = traces_dir + filter(lambda file_or_dir_name: file_or_dir_name.startswith(constellation) and not file_or_dir_name.endswith("_traces.done"),
                                                    os.listdir(traces_dir)).__next__() + "/"
            
            modname_to_satname_dict = None
            with open(const_traces_dir + "modname_to_satname_dict.json", "r") as dict_f:
                modname_to_satname_dict = json.load(dict_f)
            satnames = [modname_to_satname_dict[modname] for modname in leo_modnames]

            return [(const_traces_dir + satname + ".trace") for satname in satnames]
        
        else:
            return []

def filter_csv_paths(path_list):
    return list(filter(lambda path: path.endswith(".csv"), path_list))

rule plot_orbs_of_mobility:
    input:
        "../../scripts/plots/plot_orbs.py",
        coord_paths=get_satmod_csv_paths_or_traces_done
    output:
        "plots/orbs/mobility/{opp_config}_{coord_frame}_{leo_modnames}.html"
    params:
        csv_paths= lambda wildcards, input: quote_strs(filter_csv_paths(input.coord_paths)),
        csv_option= lambda wildcards, input: "-c" if len(filter_csv_paths(input.coord_paths)) > 0 else "",
        trace_paths= lambda wildcards, input: quote_strs(get_trace_paths(wildcards)),
        trace_option= lambda wildcards, input: "-t" if len(get_trace_paths(wildcards)) > 0 else ""
    shell:
        """
        python3 ../../scripts/plots/plot_orbs.py {params.csv_option} {params.csv_paths} {params.trace_option} {params.trace_paths} -o '{output}' -e
        """

rule plot_orbs_of_mobilities:
    input:
        "../../scripts/plots/plot_orbs.py",
        coord_paths= lambda wildcards: get_satmod_csv_paths_or_traces_done(wildcards, False)
    output:
        "plots/orbs/mobilities/" + get_debug_str() + "{constellation}_{coord_frame}_{mobility1}-{mobility2}_{leo_modnames}.html"
    params:
        csv_paths= lambda wildcards, input: quote_strs(filter_csv_paths(input.coord_paths)),
        trace_paths= lambda wildcards, input: quote_strs(get_trace_paths(wildcards, False))
    shell:
        "python3 ../../scripts/plots/plot_orbs.py -c {params.csv_paths} -t {params.trace_paths} -o '{output}' -e"
    
